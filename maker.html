<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ADHD-ifier</title>
    <link rel="icon" type="image/png" href="favicon.ico">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <!-- heic2any library for converting iPhone photos -->
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>

    <style>
        iframe[id^="firebase-app-check-debug-token"] {
            display: none !important;
        }
        /* === RETRO/PIXELATED STYLE OVERHAUL === */
        :root {
            --bg: #f2efe8;
            --ink: #2b2b2b;
            --mid: #c2c2c2;
            --light: #faf9f5;
            --shadow: #7a7a7a;
            --danger-color: #cc4444;
        }

        /* ─── Global Layout ─── */
        body {
            font-family: 'VT323', monospace;
            background: var(--bg) url('./assets/wallpaper.png') repeat fixed;
            color: var(--ink);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
        }
        * { box-sizing: border-box; }

        /* ─── Window Frame ─── */
        .window {
            background: var(--light);
            border: 2px solid var(--ink);
            box-shadow: 4px 4px 0px var(--ink);
            display: inline-block;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        .titlebar {
            height: 28px;
            background: var(--mid);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            border-bottom: 2px solid var(--ink);
            font-size: 20px;
        }
        .controls-fake { display: flex; gap: 4px; }
        .btn-square { width: 16px; height: 16px; background: var(--light); border: 2px solid var(--ink); }

        /* ─── Main Content Styling ─── */
        #adhd-meme-generator {
            font-family: 'VT323', monospace;
            color: var(--ink);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #adhd-meme-generator h2 {
            font-size: 2.5rem;
            margin: 0 0 .2rem;
            text-align: center;
            letter-spacing: 1px;
        }
        #adhd-meme-generator h3 {
            font-size: 1.2rem;
            margin: .5rem 0 .3rem;
            font-weight: normal;
        }
        #adhd-meme-generator p.tagline {
            font-size: 1.1rem;
            margin: 0 auto .5rem;
            text-align: center;
            color: var(--shadow);
        }

        /* ─── Preview Canvas ─── */
        .mg-preview canvas {
            width: 100%; height: auto;
            border: 2px solid var(--ink);
            background-color: var(--light);
        }
        /* --- NEW --- Grabbing cursor style */
        .mg-preview canvas.grabbing {
            cursor: grabbing;
        }
        .mg-preview.no-image canvas {
            border: 2px dashed var(--ink);
            cursor: pointer;
            aspect-ratio: 4/3;
        }
        .mg-preview.no-image canvas:hover { border-color: var(--shadow); }
        .mg-preview.no-image::after {
            font-size: 1.2rem;
            color: var(--shadow);
            pointer-events: none;
            text-shadow: 1px 1px var(--light);
        }
        
        /* ─── Controls & Fieldsets ─── */
        .mg-controls { display: grid; grid-template-columns: 1fr; gap: 1rem; }
        .mg-controls fieldset {
            background: var(--light);
            border: 2px solid var(--ink);
            padding: .8rem; margin: 0; text-align: left;
        }
        /* --- UPDATED --- For minimize button layout */
        .mg-controls legend {
            font-size: 1rem;
            font-weight: normal;
            padding: 0 .25rem;
            display: flex;
            align-items: center;
            width: 100%;
            gap: 0.5rem;
        }
        legend > span {
            flex-shrink: 0;
        }
        /* --- NEW --- Creates the visual line in the legend */
        .legend-line {
            flex-grow: 1;
            height: 2px;
            background-color: var(--ink);
        }
        
        .fieldset-toggle-btn {
            background: none;
            border: 1px solid var(--ink);
            color: var(--ink);
            font-family: 'VT323', monospace;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            line-height: 1;
            padding: 0 5px;
            height: 20px;
            width: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .fieldset-toggle-btn:hover {
            background-color: var(--mid);
        }
        .mg-controls fieldset.minimized .fieldset-content {
            display: none;
        }

        /* ─── Sliders ─── */
        .mg-slider {
            display: flex;
            align-items: center;
            gap: .5rem;
            margin: .4rem 0;
            width: 100%;
        }
        .mg-slider input[type="range"] {
            -webkit-appearance: none; appearance: none;
            flex: 1; height: 12px;
            background: var(--mid);
            border: 2px solid var(--ink);
            outline: none;
            padding: 0;
        }
        .mg-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px;
            background: var(--ink);
            cursor: pointer;
            margin-top: -4px;
        }
        .mg-slider input[type="range"]::-moz-range-thumb {
            width: 12px; height: 12px;
            background: var(--ink);
            border: none;
            cursor: pointer;
        }
        .mg-slider span { font-size: 1rem; width: 32px; color: var(--shadow); }
        .mg-slider-label { font-size: 1rem; width: 40px; color: var(--shadow); }
        .mg-row { display: flex; align-items: center; gap: .5rem; margin: .4rem 0; }
        
        #mg-light {
            direction: rtl;
        }

        /* ─── Textarea ─── */
        textarea#mg-text {
            width: 100%; resize: none;
            border: 2px solid var(--ink);
            padding: .3rem; background: var(--light);
            color: var(--ink);
            font-family: inherit; font-size: 1rem;
            height: 4rem;
        }
        
        /* ─── Template/Layer Selectors ─── */
        .mg-template-container { display: flex; gap: .5rem; justify-content: flex-start; flex-wrap: wrap; }
        .mg-template, .mg-template-add, .mg-template-more, .mg-text-layer-add {
            width: 80px; height: 80px;
            background: var(--light);
            border: 2px solid var(--ink);
            cursor: pointer;
            transition: all .2s;
            overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
        .mg-text-layer-add { height: 32px; font-size: 1.8rem; }
        .mg-template:hover, .mg-template-add:hover, .mg-template-more:hover, .mg-text-layer-add:hover {
            box-shadow: 2px 2px 0 var(--shadow);
            transform: translate(-1px, -1px);
        }
        .mg-template.disabled, .mg-template-add.disabled, .mg-template-more.disabled, .mg-text-layer-add.disabled {
            opacity: .5; pointer-events: none; background: var(--mid);
        }
        .mg-template-add svg, .mg-template-more svg { width: 36px; height: 36px; color: var(--ink); }

        /* ─── Main Action Buttons ─── */
        .mg-actions { display: flex; justify-content: center; gap: .5rem; margin-top: .75rem; flex-wrap: wrap;}
        .mg-btn, .mg-icon-btn {
            font-family: inherit; font-size: 18px;
            background: var(--light);
            border: 2px solid var(--ink);
            padding: 8px 16px; margin: 4px;
            cursor: pointer; text-decoration: none;
            color: var(--ink); transition: .2s all;
            box-shadow: 2px 2px 0px var(--shadow);
        }
        .mg-btn:hover, .mg-icon-btn:hover {
            transform: translate(2px, 2px);
            box-shadow: 0px 0px 0px var(--shadow);
        }
        /* --- NEW --- Active state for main buttons */
        .mg-btn.active {
            background-color: var(--mid);
            box-shadow: none;
            transform: translate(2px, 2px);
        }
        .mg-icon-btn { width: 36px; height: 36px; padding: 0; display: inline-flex; justify-content: center; align-items: center; }

        .mg-icon-btn img {
            width: 24px;
            height: 24px;
        }

        .mg-icon-btn.active {
            background-color: var(--mid);
            box-shadow: none;
            transform: translate(2px, 2px);
        }

        /* ─── Layer Thumbnails ─── */
        #mg-layers-hint {
            font-size: 0.9rem;
            color: var(--shadow);
            margin-bottom: 0.3rem;
            text-align: left;
            width: 100%;
            line-height: 1;
        }
        .mg-layer-thumb, .mg-text-thumb {
            border: 2px solid var(--ink);
            background: var(--light);
            cursor: pointer;
            transition: all .2s; opacity: .8;
            position: relative;
        }
        .mg-layer-thumb { width: 40px; height: 40px; }
        .mg-text-thumb { width: 80px; height: 32px; font-size: .9rem; padding: 0 16px 0 4px; }
        .mg-layer-thumb:hover, .mg-text-thumb:hover { opacity: 1; transform: scale(1.05); }
        .mg-layer-thumb.active, .mg-text-thumb.active {
            border: 2px solid var(--shadow);
            opacity: 1; transform: scale(1.08);
            box-shadow: 2px 2px 0px var(--shadow);
        }
        .mg-layer-thumb .delete-layer, .mg-text-thumb .delete-layer {
            background-color: var(--danger-color);
            border: 1px solid var(--ink);
        }
        
        /* ─── Layout & Responsive ─── */
        .mg-editor-layout { display: flex; flex-direction: column; gap: 1rem; width: 100%; }
        @media (min-width: 900px) {
            .mg-editor-layout {
                display: grid;
                grid-template-columns: minmax(320px, 420px) 1fr;
                gap: 1.5rem;
            }
            .mg-preview-wrapper { position: sticky; top: 1.5rem; }
        }

        /* --- MOBILE LAYOUT ADJUSTMENTS --- */
        @media (max-width: 899px) {
            body {
                padding: 10px; /* Reduce outer padding on mobile */
            }
            #adhd-meme-generator {
                padding: 0.5rem; /* Reduce inner padding on mobile */
            }
            /* --- Reorder elements for mobile view using flexbox 'order' --- */
            .mg-preview-wrapper {
                order: -1; /* Make preview appear before controls */
            }
        }

        /* ─── Toast & Overlay ─── */
        #mg-toast {
            visibility: hidden;
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            background: var(--light); border: 2px solid var(--ink);
            padding: .5rem 1rem; color: var(--ink);
            font-size: 1rem;
            z-index: 2000;
            box-shadow: 4px 4px 0 var(--ink);
        }
        #mg-template-overlay {
            background: rgba(43, 43, 43, 0.7);
            backdrop-filter: none;
        }
        #mg-template-grid-wrapper {
            background: var(--light);
            border: 2px solid var(--ink);
            box-shadow: 4px 4px 0px var(--ink);
            padding: 1.5rem;
            max-width: 480px;
            width: 90vw;
            max-height: 85vh; 
            display: flex;
            flex-direction: column;
        }
        #mg-template-grid-wrapper h4 {
            font-size: 1.5rem; text-align: center;
            font-weight: normal; margin: 0 0 1rem;
        }
        #mg-template-overlay-close {
            font-family: 'VT323', monospace; color: var(--ink);
            font-size: 2rem;
        }
        #mg-template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, 80px);
            justify-content: center;
            gap: 0.5rem;
            overflow-y: auto;
            padding: 0.5rem;
        }
        .mg-preview { width: 100%; margin: 0 auto; position: relative; display: flex; justify-content: center; align-items: center; touch-action: none; }
        .mg-preview.no-image::after { content: "Click or drag image here"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .mg-controls input[type="file"] { display: none; }
        .mg-template img { width: 100%; height: 100%; object-fit: cover; }
        .color-swatch { display: inline-block; width: 14px; height: 14px; border: 1px solid var(--ink); background: linear-gradient(45deg, #000 0%, #000 50%, #fff 50%, #fff 100%); }
        .mg-layers { display: flex; gap: .3rem; flex-wrap: wrap; margin-top: .5rem; justify-content: flex-start; }
        #mg-template-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; display: flex; align-items: center; justify-content: center; opacity: 0; visibility: hidden; pointer-events: none; transition: opacity 0.3s, visibility 0s 0.3s; }
        #mg-template-overlay.visible { opacity: 1; visibility: visible; pointer-events: auto; transition: opacity 0.3s, visibility 0s 0s; }
        #mg-template-overlay-close { position: absolute; top: 8px; right: 10px; background: none; border: none; line-height: 1; cursor: pointer; padding: 5px; }
        .mg-layer-thumb .delete-layer, .mg-text-thumb .delete-layer { position: absolute; top: -1px; right: -1px; color: #fff; font-size: .7rem; font-weight: bold; line-height: 1; padding: 1px 4px; cursor: pointer; }
    
        /* --- NEW --- Styles for Pan/Zoom controls */
        .hidden { display: none !important; }
        #mg-zoom-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #mg-zoom-controls button {
            font-family: inherit;
            font-size: 24px;
            line-height: 1;
            font-weight: bold;
            width: 36px; height: 36px;
            background: var(--light);
            border: 2px solid var(--ink);
            color: var(--ink);
            cursor: pointer;
            box-shadow: 2px 2px 0px var(--shadow);
            transition: .2s all;
        }
         #mg-zoom-controls button:hover {
            transform: translate(2px, 2px);
            box-shadow: 0px 0px 0px var(--shadow);
        }
    </style>
</head>
<body>

<div class="window">
    <div class="titlebar">
      <span>ADHD-ifier.exe</span>
      <div class="controls-fake">
        <div class="btn-square"></div><div class="btn-square"></div>
      </div>
    </div>
    
    <section id="adhd-meme-generator">
        <h2>ADHD-ifier Meme Maker</h2>
        <p class="tagline">Upload → add character → adjust → add text → download/share</p>
        
        <div class="mg-editor-layout">
            <div class="mg-controls-wrapper">
                <div class="mg-controls">
                    <fieldset>
                        <legend>
                            <span>1. Template</span>
                            <div class="legend-line"></div>
                            <button class="fieldset-toggle-btn" aria-label="Minimize section" aria-expanded="true">—</button>
                        </legend>
                        <div class="fieldset-content">
                            <!-- Hint will be inserted here by JS -->
                            <div id="mg-layers" class="mg-layers"></div>
                            <h3>Add Layer</h3>
                            <div class="mg-template-container">
                                <div class="mg-template disabled" data-template="./assets/maker/1.png"><img src="./assets/maker/1.png" alt="Template 1"></div>
                                <div class="mg-template disabled" data-template="./assets/maker/2.png"><img src="./assets/maker/2.png" alt="Template 2"></div>
                                <div class="mg-template disabled" data-template="./assets/maker/3.png"><img src="./assets/maker/3.png" alt="Template 3"></div>
                                <div class="mg-template disabled" data-template="./assets/maker/4.png"><img src="./assets/maker/4.png" alt="Template 4"></div>
                                <div class="mg-template-more disabled" id="mg-template-more" title="More templates">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M10 3H4v8h7V4h-1zm-5 5H4V4h4v4H5zM10 13H4v8h7v-7h-1zm-5 5H4v-4h4v4H5zM20 3h-6v8h7V4h-1zm-5 5h-1V4h4v4h-3zM20 13h-6v8h7v-7h-1zm-5 5h-1v-4h4v4h-3z"/></svg>
                                </div>
                                <label class="mg-template-add disabled" id="mg-template-add" title="Add Custom PNG">
                                    <input type="file" id="mg-template-file" accept="image/png"/>
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M13 10h5l-6-7-6 7h5v6h2v-6zM4 18v2h16v-2H4z"/></svg>
                                </label>
                            </div>
                            <div class="mg-slider" style="margin-top: 0.5rem;">
                                <span class="mg-slider-label">Opacity</span>
                                <input type="range" id="mg-opacity" min="0" max="100" value="100" disabled/>
                                <span id="mg-opacity-val">100</span>
                            </div>
                            <div class="mg-slider">
                                <span class="mg-slider-label">Light</span>
                                <input type="range" id="mg-light" min="0" max="100" value="0" disabled/>
                                <span id="mg-light-val">0</span>
                            </div>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>
                            <span>2. Size/Position</span>
                            <div class="legend-line"></div>
                            <button class="fieldset-toggle-btn" aria-label="Minimize section" aria-expanded="true">—</button>
                        </legend>
                        <div class="fieldset-content">
                            <div class="mg-slider"><span class="mg-slider-label">X pos</span><input type="range" id="mg-pos-x" min="0" max="100" value="50" disabled/><span id="mg-pos-x-val">50</span></div>
                            <div class="mg-slider"><span class="mg-slider-label">Y pos</span><input type="range" id="mg-pos-y" min="0" max="100" value="50" style="transform: scaleY(-1);" disabled/><span id="mg-pos-y-val">50</span></div>
                            <div class="mg-slider"><span class="mg-slider-label">Size</span><input type="range" id="mg-size" min="10" max="200" value="100" disabled/><span id="mg-size-val">100</span></div>
                            <div class="mg-slider"><span class="mg-slider-label">Crop</span><input type="range" id="mg-crop-y" min="0" max="99" value="0" disabled/><span id="mg-crop-y-val">0</span></div>
                            <div class="mg-slider"><span class="mg-slider-label">Rotate</span><input type="range" id="mg-rotate" min="0" max="360" value="0" disabled/><span id="mg-rotate-val">0</span></div>
                            
                            <div class="mg-row" style="justify-content:center; gap: 1rem;">
                                <button class="mg-icon-btn" id="mg-rotate-icon" disabled title="Rotate 90°">↻</button>
                                <button class="mg-icon-btn" id="mg-flip-icon" disabled title="Flip Horizontally">⇆</button>
                                
                                <button class="mg-icon-btn" id="mg-erase-toggle" disabled title="Toggle Eraser Mode">
                                    <img src="./assets/maker/erase.png" alt="Erase">
                                </button>
                                
                                <button class="mg-icon-btn" id="mg-unerase-toggle" disabled title="Toggle Unerase Mode">
                                   <img src="./assets/maker/unerase.png" alt="Un-erase">
                                </button>

                                <button class="mg-icon-btn" id="mg-undo" disabled title="Undo (Cmd/Ctrl+Z)">
                                    <img src="./assets/maker/undo.png" alt="Undo">
                                </button>
                            </div>

                             <div class="mg-slider">
                                <span class="mg-slider-label">Brush</span>
                                <input type="range" id="mg-erase-size" min="1" max="150" value="100" disabled/>
                                <span id="mg-erase-size-val">100</span>
                            </div>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>
                            <span>3. Text</span>
                            <div class="legend-line"></div>
                            <button class="fieldset-toggle-btn" aria-label="Minimize section" aria-expanded="true">—</button>
                        </legend>
                        <div class="fieldset-content">
                            <div id="mg-text-layer-bar" class="mg-template-container" style="margin-bottom:.5rem">
                                <div id="mg-text-layer-add" class="mg-text-layer-add disabled" title="Add text layer"><span>+</span></div>
                            </div>
                            <textarea id="mg-text" rows="2" placeholder="Meme text" disabled></textarea>
                            <div class="mg-slider"><span class="mg-slider-label">Size</span><input type="range" id="mg-text-size" min="10" max="150" value="40" disabled/><span id="mg-text-size-val">40</span></div>
                            <div class="mg-slider"><span class="mg-slider-label">X pos</span><input type="range" id="mg-text-pos-x" min="0" max="100" value="50" disabled/><span id="mg-text-pos-x-val">50</span></div>
                            <div class="mg-slider"><span class="mg-slider-label">Y pos</span><input type="range" id="mg-text-pos-y" min="0" max="100" value="50" disabled/><span id="mg-text-pos-y-val">50</span></div>
                            <div class="mg-row" style="justify-content: center;">
                                <button class="mg-icon-btn" id="mg-text-color-toggle" disabled title="Toggle Text Color"><span class="color-swatch"></span></button>
                            </div>
                        </div>
                    </fieldset>
                </div>
            </div>
            
            <div class="mg-preview-wrapper">
                <div class="mg-preview no-image">
                    <canvas id="mg-canvas" width="800" height="600"></canvas>
                    <input type="file" id="mg-file" accept="image/*" style="display:none"/>
                    <!-- --- NEW --- Zoom controls for desktop -->
                    <div id="mg-zoom-controls" class="hidden">
                        <button id="mg-zoom-in">+</button>
                        <button id="mg-zoom-out">−</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="mg-actions">
            <!-- --- NEW --- Pan/Zoom button -->
            <button class="mg-btn" id="mg-panzoom-toggle">Pan/Zoom</button>
            <button class="mg-btn" id="mg-reset">Reset</button>
            <button class="mg-btn" id="mg-download">Download</button>
            <button class="mg-btn" id="mg-share">Share on X</button>
        </div>
    </section>
</div>

<div id="mg-toast"></div>

<!-- --- UNCHANGED --- Template Overlay -->
<div id="mg-template-overlay">
    <!-- ... overlay content ... -->
</div>

<script>
    (function () {
        // ---UNCHANGED: Element references (mostly) ---
        const fileInput = document.getElementById('mg-file');
        const canvas = document.getElementById('mg-canvas');
        const preview = document.querySelector('.mg-preview');
        const previewWrapper = document.querySelector('.mg-preview-wrapper');
        const ctx = canvas.getContext('2d');
        const txtArea = document.getElementById('mg-text');
        const txtSizeEl = document.getElementById('mg-text-size');
        const txtPosXEl = document.getElementById('mg-text-pos-x');
        const txtPosYEl = document.getElementById('mg-text-pos-y');
        const textColorToggle = document.getElementById('mg-text-color-toggle');
        const templateOverlay = document.getElementById('mg-template-overlay');
        const moreTemplatesBtn = document.getElementById('mg-template-more');
        const closeOverlayBtn = document.getElementById('mg-template-overlay-close');
        const eraseToggleBtn = document.getElementById('mg-erase-toggle');
        const uneraseToggleBtn = document.getElementById('mg-unerase-toggle');
        const undoBtn = document.getElementById('mg-undo');
        const eraseSizeSlider = document.getElementById('mg-erase-size');
        const eraseSizeVal = document.getElementById('mg-erase-size-val');

        // --- NEW --- Pan/Zoom Element references
        const panZoomToggleBtn = document.getElementById('mg-panzoom-toggle');
        const zoomControls = document.getElementById('mg-zoom-controls');
        const zoomInBtn = document.getElementById('mg-zoom-in');
        const zoomOutBtn = document.getElementById('mg-zoom-out');

        let img = null, layers = [], activeLayer = null, textLayers = [], activeTextLayer = null;
        let interaction = { active: false };
        let brushMode = 'none';
        let eraserSize = 100;
        const tempLayerCanvas = document.createElement('canvas');
        const tempLayerCtx = tempLayerCanvas.getContext('2d');
        let historyStack = [];
        const HISTORY_LIMIT = 50;
        const HANDLE_SIZE = 12;
        const TOUCH_HANDLE_RADIUS = 40;
        const DPR = window.devicePixelRatio || 1;

        // --- NEW --- State for pan/zoom mode and camera properties
        let panZoomModeActive = false;
        let camera = { x: 0, y: 0, scale: 1 };


        // ---UNCHANGED: Core drawing and utility functions---
        function resizeCanvasCSS(w, h) {
            canvas.width = w * DPR; canvas.height = h * DPR;
            ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.scale(DPR, DPR);
            ctx.imageSmoothingEnabled = false;
        }
        const W = () => canvas.width / DPR;
        const H = () => canvas.height / DPR;
        const toast = (msg) => {
            const t = document.getElementById('mg-toast');
            t.textContent = msg; t.style.opacity = 1; t.style.visibility = 'visible';
            setTimeout(() => { t.style.opacity = 0; t.style.visibility = 'hidden'; }, 2400);
        };
        
        function fitCanvasToContainer() {
            if (!img) return;
            canvas.style.width = ''; canvas.style.height = '';

            const isMobile = window.innerWidth < 900;
            const heightMultiplier = isMobile ? 0.95 : 0.85;

            const containerWidth = previewWrapper.clientWidth;
            const containerHeight = window.innerHeight * heightMultiplier; 
            const imgAspectRatio = img.naturalWidth / img.naturalHeight;
            const containerAspectRatio = containerWidth / containerHeight;
            
            if (imgAspectRatio > containerAspectRatio) {
                canvas.style.width = containerWidth + 'px';
                canvas.style.height = 'auto';
            } else {
                canvas.style.height = containerHeight + 'px';
                canvas.style.width = 'auto';
            }
        }

        // ---UNCHANGED: Control update logic...
        function updateCursor() {
            if (panZoomModeActive) {
                canvas.style.cursor = interaction.active && interaction.type === 'panCamera' ? 'grabbing' : 'grab';
            } else {
                canvas.style.cursor = brushMode !== 'none' && activeLayer !== null ? 'none' : '';
            }
        }
        // ... rest of the update control functions are unchanged
        function updateAllControls() { updateImageControls(); updateTextControls(); }
        function updateImageControls() {
            const disabled = activeLayer === null || panZoomModeActive;
            document.getElementById('mg-pos-x').disabled = disabled;
            document.getElementById('mg-pos-y').disabled = disabled;
            document.getElementById('mg-size').disabled = disabled;
            document.getElementById('mg-crop-y').disabled = disabled;
            document.getElementById('mg-rotate').disabled = disabled;
            document.getElementById('mg-opacity').disabled = disabled;
            document.getElementById('mg-light').disabled = disabled;
            document.getElementById('mg-rotate-icon').disabled = disabled;
            document.getElementById('mg-flip-icon').disabled = disabled;

            const brushToolsDisabled = disabled || brushMode === 'none';
            eraseToggleBtn.disabled = disabled;
            uneraseToggleBtn.disabled = disabled;
            eraseSizeSlider.disabled = brushToolsDisabled;

            eraseToggleBtn.classList.toggle('active', brushMode === 'erase' && !disabled);
            uneraseToggleBtn.classList.toggle('active', brushMode === 'unerase' && !disabled);
            
            undoBtn.disabled = historyStack.length === 0 || panZoomModeActive;

            if (!disabled && layers[activeLayer]) {
                const l = layers[activeLayer];
                document.getElementById('mg-pos-x').value = l.x;
                document.getElementById('mg-pos-x-val').textContent = Math.round(l.x);
                document.getElementById('mg-pos-y').value = 100 - l.y;
                document.getElementById('mg-pos-y-val').textContent = Math.round(l.y);
                document.getElementById('mg-size').value = l.size;
                document.getElementById('mg-size-val').textContent = Math.round(l.size);
                document.getElementById('mg-crop-y').value = l.cropY;
                document.getElementById('mg-crop-y-val').textContent = Math.round(l.cropY);
                document.getElementById('mg-rotate').value = l.rot;
                document.getElementById('mg-rotate-val').textContent = Math.round(l.rot);
                document.getElementById('mg-opacity').value = l.opacity ?? 100;
                document.getElementById('mg-opacity-val').textContent = Math.round(l.opacity ?? 100);
                document.getElementById('mg-light').value = l.light ?? 0;
                document.getElementById('mg-light-val').textContent = Math.round(l.light ?? 0);
            }
            if (!brushToolsDisabled) {
                eraseSizeSlider.value = eraserSize;
                eraseSizeVal.textContent = eraserSize;
            }
            updateCursor();
        }
        function updateTextControls() {
            txtArea.disabled = img === null || panZoomModeActive;
            const controlsDisabled = activeTextLayer === null || panZoomModeActive;
            txtSizeEl.disabled = controlsDisabled;
            txtPosXEl.disabled = controlsDisabled;
            txtPosYEl.disabled = controlsDisabled;
            textColorToggle.disabled = controlsDisabled;
            if (!controlsDisabled && textLayers[activeTextLayer]) {
                const t = textLayers[activeTextLayer];
                txtArea.value = t.text;
                txtSizeEl.value = t.size;
                document.getElementById('mg-text-size-val').textContent = Math.round(t.size);
                txtPosXEl.value = t.x;
                document.getElementById('mg-text-pos-x-val').textContent = Math.round(t.x);
                txtPosYEl.value = t.y;
                document.getElementById('mg-text-pos-y-val').textContent = Math.round(t.y);
            } else {
                txtArea.value = '';
            }
        }
        
        // ---UNCHANGED: Layer selection, history, UI refresh logic...
        function selectLayer(i) {
            activeLayer = i; activeTextLayer = null;
            refreshLayerUI(); refreshTextThumbs(); updateAllControls(); draw();
        }
        function selectTextLayer(i) {
            brushMode = 'none';
            activeTextLayer = i; activeLayer = null;
            refreshLayerUI(); refreshTextThumbs(); updateAllControls(); draw();
        }
        function deselectAll() {
            brushMode = 'none';
            activeLayer = null; activeTextLayer = null;
            refreshLayerUI(); refreshTextThumbs(); updateAllControls(); draw();
        }
        // ... (createSnapshot, pushStateToHistory, performUndo, refreshLayerUI, refreshTextThumbs, text layer functions are all unchanged)
        
        // --- NEW --- Camera clamping function
        function clampCamera() {
            camera.scale = Math.max(1, camera.scale); // Cannot zoom out more than 1x
            
            const maxPanX = 0;
            const minPanX = -(W() * camera.scale - W());
            const maxPanY = 0;
            const minPanY = -(H() * camera.scale - H());

            camera.x = Math.max(minPanX, Math.min(maxPanX, camera.x));
            camera.y = Math.max(minPanY, Math.min(maxPanY, camera.y));
        }

        // --- MODIFIED --- Main draw function now uses camera state
        function draw() {
            ctx.clearRect(0, 0, W(), H());

            // --- NEW --- Apply camera transformations
            ctx.save();
            ctx.translate(camera.x, camera.y);
            ctx.scale(camera.scale, camera.scale);

            if (img) ctx.drawImage(img, 0, 0, W(), H());
            
            layers.forEach(l => {
                const scale = l.size / 100;
                const cropPercent = (l.cropY || 0) / 100;
                const sWidth = l.img.naturalWidth;
                const sHeight = l.img.naturalHeight * (1 - cropPercent);
                if (sHeight <= 0) return;
                const dWidth = sWidth * scale;
                const dHeight = sHeight * scale;
                const x = W() * (l.x / 100);
                const y = H() * (l.y / 100);
                const yOffset = (l.img.naturalHeight * cropPercent * scale) / 2;
                
                const lightValue = l.light ?? 0;
                const needsTempCanvas = l.eraseMask || lightValue > 0;
                let imageToDraw = l.img;

                if (needsTempCanvas) {
                    if (tempLayerCanvas.width !== l.img.naturalWidth || tempLayerCanvas.height !== l.img.naturalHeight) {
                        tempLayerCanvas.width = l.img.naturalWidth;
                        tempLayerCanvas.height = l.img.naturalHeight;
                    } else {
                        tempLayerCtx.clearRect(0, 0, tempLayerCanvas.width, tempLayerCanvas.height);
                    }
                    
                    tempLayerCtx.drawImage(l.img, 0, 0);

                    if (l.eraseMask) {
                        tempLayerCtx.globalCompositeOperation = 'destination-out';
                        tempLayerCtx.drawImage(l.eraseMask, 0, 0);
                        tempLayerCtx.globalCompositeOperation = 'source-over';
                    }
                    
                    if (lightValue > 0) {
                        tempLayerCtx.globalCompositeOperation = 'source-atop';
                        tempLayerCtx.fillStyle = `rgba(0, 0, 0, ${lightValue / 100})`;
                        tempLayerCtx.fillRect(0, 0, tempLayerCanvas.width, tempLayerCanvas.height);
                        tempLayerCtx.globalCompositeOperation = 'source-over';
                    }

                    imageToDraw = tempLayerCanvas;
                }

                ctx.save();
                ctx.globalAlpha = (l.opacity ?? 100) / 100;
                ctx.translate(x, y - yOffset);
                ctx.rotate((l.rot * Math.PI) / 180); 
                ctx.scale(l.flip ? -1 : 1, 1);
                ctx.drawImage(imageToDraw, 0, 0, sWidth, sHeight, -dWidth / 2, -dHeight / 2, dWidth, dHeight);
                ctx.restore();
            });

            textLayers.forEach(t => {
                if (!t.text.trim()) return;
                const fontPx = t.size * (W() / 800);
                ctx.font = `700 ${fontPx}px 'Poppins', 'Arial Black', sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.lineWidth = fontPx * 0.12;
                ctx.fillStyle = t.color === 'white' ? '#ffffff' : '#000000';
                ctx.strokeStyle = t.color === 'white' ? '#000000' : '#ffffff';
                const lines = t.text.split('\n'), lineHeight = fontPx * 1.1;
                const totalHeight = lines.length * lineHeight, startY = H() * (t.y / 100) - totalHeight / 2;
                lines.forEach((line, i) => {
                    const y = startY + i * lineHeight + lineHeight / 2;
                    ctx.strokeText(line, W() * (t.x / 100), y);
                    ctx.fillText(line, W() * (t.x / 100), y);
                });
            });

            const highlightColor = '#00FF00';
            if (activeLayer !== null && layers[activeLayer]) {
                const l = layers[activeLayer];
                const scale = l.size / 100;
                const cropPercent = (l.cropY || 0) / 100;
                const w = l.img.naturalWidth * scale;
                const h = l.img.naturalHeight * (1 - cropPercent) * scale;
                const x = W() * (l.x / 100);
                const y = H() * (l.y / 100);
                const yOffset = (l.img.naturalHeight * cropPercent * scale) / 2;
                
                ctx.save();
                ctx.translate(x, y - yOffset);
                ctx.rotate((l.rot * Math.PI) / 180);
                ctx.strokeStyle = highlightColor; ctx.lineWidth = 2; ctx.strokeRect(-w/2, -h/2, w, h);
                ctx.fillStyle = highlightColor;
                const ho = HANDLE_SIZE / 2;
                ctx.fillRect(-w/2-ho, -h/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                ctx.fillRect(w/2-ho, -h/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                ctx.fillRect(-w/2-ho, h/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                ctx.fillRect(w/2-ho, h/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                ctx.restore();
            }
            
            if (activeTextLayer !== null && textLayers[activeTextLayer]) {
                const t = textLayers[activeTextLayer];
                if (t.text.trim()) {
                    const bounds = getTextBounds(t);
                    ctx.strokeStyle = highlightColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);

                    const ho = HANDLE_SIZE / 2;
                    ctx.fillStyle = highlightColor;
                    ctx.fillRect(bounds.x - ho, bounds.y - ho, HANDLE_SIZE, HANDLE_SIZE);
                    ctx.fillRect(bounds.x + bounds.width - ho, bounds.y - ho, HANDLE_SIZE, HANDLE_SIZE);
                    ctx.fillRect(bounds.x - ho, bounds.y + bounds.height - ho, HANDLE_SIZE, HANDLE_SIZE);
                    ctx.fillRect(bounds.x + bounds.width - ho, bounds.y + bounds.height - ho, HANDLE_SIZE, HANDLE_SIZE);
                }
            }
            
            // --- NEW --- Restore camera before drawing cursor
            ctx.restore();

            // --- MODIFIED --- Draw brush cursor *after* camera restore so it isn't zoomed/panned
            if (brushMode !== 'none' && activeLayer !== null && interaction.lastPoint) {
                const point = interaction.lastPoint;
                const isUnerase = brushMode === 'unerase';
                // Transform point from world space to view space for drawing
                const viewPointX = point.x * camera.scale + camera.x;
                const viewPointY = point.y * camera.scale + camera.y;

                ctx.save();
                ctx.strokeStyle = isUnerase ? '#007BFF' : '#000000';
                ctx.fillStyle = isUnerase ? 'rgba(0, 123, 255, 0.3)' : 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(viewPointX, viewPointY, (eraserSize / 2) * camera.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // ---UNCHANGED--- File handling, image adding/resizing...
        
        // --- MODIFIED --- getCanvasPoint now accounts for the camera
        function getCanvasPoint(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            // Calculate point in canvas's view space
            const viewX = (clientX - rect.left) / rect.width * W();
            const viewY = (clientY - rect.top) / rect.height * H();

            // Transform back from view-space to world-space
            const worldX = (viewX - camera.x) / camera.scale;
            const worldY = (viewY - camera.y) / camera.scale;
            
            return { x: worldX, y: worldY };
        }

        // ---UNCHANGED--- Handle finding...
        function getHandleAtPoint(point, bounds, rotation = 0, radius = HANDLE_SIZE) {
            // ... (this function is unchanged)
        }
        
        // --- MODIFIED --- Interaction handlers now split between Pan/Zoom and Layer editing
        function handleInteractionStart(e) {
            if (!img) { fileInput.click(); return; }
            const isTouchEvent = !!e.touches;

            // --- NEW --- Pan/Zoom interaction logic
            if (panZoomModeActive) {
                e.preventDefault();
                if (isTouchEvent && e.touches.length === 2) {
                    const t1 = e.touches[0], t2 = e.touches[1];
                    const dx = t2.clientX - t1.clientX, dy = t2.clientY - t1.clientY;
                    interaction = {
                        active: true, type: 'zoomCamera',
                        initialDist: Math.hypot(dx, dy),
                        initialMidpoint: getMidpoint(t1, t2),
                        initialState: JSON.parse(JSON.stringify(camera))
                    };
                } else {
                    const rect = canvas.getBoundingClientRect();
                    const clientX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                    const clientY = isTouchEvent ? e.touches[0].clientY : e.clientY;
                    interaction = {
                        active: true, type: 'panCamera',
                        startX: clientX, startY: clientY,
                        initialState: JSON.parse(JSON.stringify(camera))
                    };
                    updateCursor();
                }
                return;
            }

            // --- OLD --- Layer interaction logic (now in an 'else' block)
            if (isTouchEvent && e.touches.length === 2 && activeLayer !== null) {
                // ... (existing pinch-to-zoom layer logic is unchanged)
            }
            
            e.preventDefault();
            const point = getCanvasPoint(e);
            
            if (brushMode === 'none' && (!interaction.active || interaction.type !== 'pinchLayer')) {
                 pushStateToHistory();
            }

            if (brushMode !== 'none' && activeLayer !== null) {
                // ... (existing brush logic is unchanged)
                return;
            }
            
            interaction.startX = point.x; interaction.startY = point.y;

            // ... (rest of existing layer/text selection/drag/resize logic is unchanged)
        }
        
        function handleInteractionMove(e) {
            // --- NEW --- Pan/Zoom move logic
            if (panZoomModeActive && interaction.active) {
                e.preventDefault();
                const isTouchEvent = !!e.touches;

                if (interaction.type === 'panCamera') {
                    const clientX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                    const clientY = isTouchEvent ? e.touches[0].clientY : e.clientY;
                    const dx = clientX - interaction.startX;
                    const dy = clientY - interaction.startY;
                    camera.x = interaction.initialState.x + dx;
                    camera.y = interaction.initialState.y + dy;
                } else if (interaction.type === 'zoomCamera' && isTouchEvent && e.touches.length === 2) {
                    const t1 = e.touches[0], t2 = e.touches[1];
                    const currentDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    const currentMidpoint = getMidpoint(t1,t2);

                    const scaleRatio = currentDist / interaction.initialDist;
                    const newScale = interaction.initialState.scale * scaleRatio;
                    
                    // Zoom from midpoint
                    camera.x = currentMidpoint.x - (interaction.initialMidpoint.x - interaction.initialState.x) * (newScale / interaction.initialState.scale);
                    camera.y = currentMidpoint.y - (interaction.initialMidpoint.y - interaction.initialState.y) * (newScale / interaction.initialState.scale);
                    camera.scale = newScale;
                }
                clampCamera();
                draw();
                return;
            }
            
            // --- OLD --- Layer move logic
            if (interaction.active) {
                // ... (existing layer/text move/resize/brush logic is unchanged)
            } else {
                interaction.lastPoint = getCanvasPoint(e); if (brushMode !== 'none') draw(); 
                return;
            }
        }
        
        function handleInteractionEnd() { 
            if (panZoomModeActive) {
                interaction.active = false;
                updateCursor();
                return;
            }
             if (interaction.active && interaction.type === 'brush') {
                pushStateToHistory();
            }
            interaction.active = false;
        }

        // ---UNCHANGED--- Template overlay logic...
        
        function setupListeners() {
            // ... (existing listeners are unchanged up to the action buttons)

            // --- NEW --- Listeners for Pan/Zoom
            panZoomToggleBtn.addEventListener('click', () => {
                panZoomModeActive = !panZoomModeActive;
                panZoomToggleBtn.classList.toggle('active', panZoomModeActive);
                
                if (panZoomModeActive) {
                    deselectAll(); // Deselect layers to hide highlights
                    toast("Pan/Zoom Mode On");
                } else {
                    toast("Pan/Zoom Mode Off");
                }
                
                const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
                zoomControls.classList.toggle('hidden', !panZoomModeActive || isTouchDevice);
                
                updateAllControls(); // Disable/enable controls
                updateCursor();
            });

            const zoomWithButtons = (factor) => {
                if (!panZoomModeActive) return;
                const newScale = camera.scale * factor;
                const rect = canvas.getBoundingClientRect();
                const viewCenterX = rect.width / 2;
                const viewCenterY = rect.height / 2;
                
                // Zoom from center of view
                camera.x = viewCenterX - (viewCenterX - camera.x) * (newScale / camera.scale);
                camera.y = viewCenterY - (viewCenterY - camera.y) * (newScale / camera.scale);
                camera.scale = newScale;

                clampCamera();
                draw();
            };

            zoomInBtn.addEventListener('click', () => zoomWithButtons(1.2));
            zoomOutBtn.addEventListener('click', () => zoomWithButtons(1 / 1.2));

            // ... (rest of existing listeners are unchanged)

            document.getElementById('mg-download').addEventListener('click', () => {
                if (!img) return toast('Upload an image first');
                // --- MODIFIED --- Temporarily reset camera for download
                const tempCamera = { ...camera };
                camera = { x: 0, y: 0, scale: 1 };
                panZoomModeActive = false; // Ensure highlights are off
                panZoomToggleBtn.classList.remove('active');
                zoomControls.classList.add('hidden');
                deselectAll();
                setTimeout(() => {
                    const link = document.createElement('a');
                    link.download = `adhd-meme.png`;
                    link.href = canvas.toDataURL('image/png', 0.95);
                    link.click();
                    // Restore camera state
                    camera = tempCamera;
                    draw();
                }, 50);
            });
            // ... (the rest of the listeners are unchanged)
        }

        function resetApp() {
            img = null; layers = []; activeLayer = null; textLayers = []; activeTextLayer = null;
            brushMode = 'none';
            eraserSize = 100;
            historyStack = [];
            fileInput.value = null;

            // --- NEW --- Reset camera and pan/zoom state
            panZoomModeActive = false;
            camera = { x: 0, y: 0, scale: 1 };
            panZoomToggleBtn.classList.remove('active');
            zoomControls.classList.add('hidden');

            preview.classList.add('no-image');
            canvas.style.width = ''; canvas.style.height = '';
            document.querySelectorAll('.mg-template, .mg-template-add, .mg-template-more, #mg-text-layer-add').forEach(el => el.classList.add('disabled'));
            refreshLayerUI(); refreshTextThumbs(); updateAllControls();
            resizeCanvasCSS(800, 600); draw();
        }

        setupListeners();
        resetApp();
    })();
</script>

</body>
</html>
